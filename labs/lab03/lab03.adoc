= Enhancing Boot Application with Metrics

== Set up the Actuator

Spring Boot includes a number of additional features to help you monitor and manage your application when it’s pushed to production. These features are added by adding _spring-boot-starter-actuator_ to the classpath.  During our initial project setup with *start.spring.io* we've already included that.

. Verify the Spring Boot Actuator dependency in the following file: */cloud-native-spring/pom.xml*.  You should see the following dependency in the list:
+
[source, xml]
---------------------------------------------------------------------
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
---------------------------------------------------------------------

**Actuator Endpoint**

Now that we have set up our simple application, it is time to take a look at what Spring Actuator has to offer. 

. Run the updated application
+
[source,bash]
---------------------------------------------------------------------
$ mvn clean spring-boot:run
---------------------------------------------------------------------

In the browser, go to the URL http://localhost:8080/actuator/. This shows us an overview of the exposed Actuator endpoints. Compared to Spring Boot 1, the Actuator endpoints all reside after this Actuator endpoint. This should prevent naming collisions with your own endpoints whenever they would have the same name as Actuator endpoints. 

As you can see, only 3 Actuator endpoints are exposed by default. In order to expose more endpoints, we need to add an include or exclude configuration to the application.properties file. We will add all endpoints to the configuration, but you can also limit the exposed endpoints by means of a comma-separated list. In order to expose all endpoints, we add the following configuration to the application.properties file:


[source,bash]
---------------------------------------------------------------------
management.endpoints.web.exposure.include=*

---------------------------------------------------------------------

Restart the application and try out the following endpoints. The output is omitted here because it can be quite large:

http://localhost:8080/actuator/health

Displays Application and Datasource health information.  This can be customized based on application functionality, which we'll do later.

http://localhost:8080/actuator/beans

Dumps all of the beans in the Spring context.

http://localhost:8080/actuator/configprops

Displays a collated list of all @ConfigurationProperties.

http://localhost:8080/actuator/env

Dumps the application’s shell environment as well as all Java system properties.

http://localhost:8080/actuator/mappings

Dumps all URI request mappings and the controller methods to which they are mapped.

http://localhost:8080/actuator/heapdump

Performs a heap dump.

http://localhost:8080/actuator/threaddump

Performs a thread dump.

http://localhost:8080/actuator/trace

Displays trace information (by default the last few HTTP requests).

**Secure the Endpoints**

Most of the time, we do not want this kind of information to be accessible by everyone. In that case, we can secure the Actuator endpoints. First of all, we will add Spring Security to the pom:

[source,bash]
---------------------------------------------------------------------
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
---------------------------------------------------------------------

Just by adding the above dependency Spring  Security presents us a login page when trying to access the Actuator endpoints and also our own base endpoint. We can login with user *user* and the password which is available in the Spring Boot log. This looks like the following (of course the hash changes after each startup):

[source,bash]
---------------------------------------------------------------------
Using generated security password: 8da882c3-4bbb-4e71-88c2-13399d9f0724
---------------------------------------------------------------------
We can put our own user name and passwd also by adding the following lines to the application.properties file :

[source,bash]
---------------------------------------------------------------------
spring.security.user.name=pal
spring.security.user.password=pal123
spring.security.user.roles=ACTUATOR
---------------------------------------------------------------------

Now let's assume that we only want to secure the Actuator endpoints and not our own base endpoint. According to the Spring documentation (https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-Security-2.0)we need to add the following configuration class:

[source,bash]
---------------------------------------------------------------------
@Configuration
public class ActuatorSecurity extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests()
      .anyRequest().hasRole("ADMIN")
      .and()
      .httpBasic();
  }
}
---------------------------------------------------------------------

**The Actuator Health Endpoint**

The Actuator health endpoint, by default, shows no detail. Several built-in healthindicators are present, and the information to show is collected from these healthindicators. But by default, you will only see the following:


[source,bash]
---------------------------------------------------------------------
{
    "status": "UP"
}

---------------------------------------------------------------------


. Create the class _io.pivotal.FlappingHealthIndicator_ (/cloud-native-spring/src/main/java/io/pivotal/FlappingHealthIndicator.java) and into it paste the following code:
+
[source,java]
---------------------------------------------------------------------
package io.pivotal;

import java.util.Random;

import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

@Component
public class FlappingHealthIndicator implements HealthIndicator {

    private Random random = new Random(System.currentTimeMillis());

    @Override
    public Health health() {
        int result = random.nextInt(100);
        if (result < 50) {
            return Health.down().withDetail("flapper", "failure").withDetail("random", result).build();
        } else {
            return Health.up().withDetail("flapper", "ok").withDetail("random", result).build();
        }
    }
}
---------------------------------------------------------------------
+
This demo health indicator will randomize the health check.

. Build and run the _cloud-native-spring_ application:
+
[source,bash]
---------------------------------------------------------------------
$ mvn clean spring-boot:run
---------------------------------------------------------------------

. Browse to http://localhost:8080/health and verify that the output is similar to the following (and changes randomly!).
+
[source,json]
---------------------------------------------------------------------
{
  "status": "UP",
  "flapping": {
      "status": "UP",
      "flapper": "ok",
      "random": 42
  },
  "diskSpace": {
      "status": "UP",
      "free": 42345678945,
      "threshold": 12345678
  }
}
---------------------------------------------------------------------

== Metrics

Spring Boot provides an endpoint http://localhost:8080/metrics that exposes several automatically collected metrics for your application. It also allows for the creation of custom metrics.

. Browse to http://localhost:8080/metrics. Review the metrics exposed.
+
[source,json]
---------------------------------------------------------------------
{
"mem": 418830,
"mem.free": 239376,
"processors": 8,
"instance.uptime": 59563,
"uptime": 69462,
"systemload.average": 1.5703125,
"heap.committed": 341504,
"heap.init": 262144,
"heap.used": 102127,
"heap": 3728384,
"nonheap.committed": 79696,
"nonheap.init": 2496,
"nonheap.used": 77326,
"nonheap": 0,
"threads.peak": 14,
"threads.daemon": 11,
"threads.totalStarted": 17,
"threads": 13,
"classes": 9825,
"classes.loaded": 9825,
"classes.unloaded": 0,
"gc.ps_scavenge.count": 9,
"gc.ps_scavenge.time": 80,
"gc.ps_marksweep.count": 2,
"gc.ps_marksweep.time": 157,
"httpsessions.max": -1,
"httpsessions.active": 0,
"gauge.response.metrics": 75,
"gauge.response.star-star.favicon.ico": 9,
"counter.status.200.star-star.favicon.ico": 1,
"counter.status.200.metrics": 1
}
---------------------------------------------------------------------

. Stop the cloud-native-spring application.

== Deploy _cloud-native-spring_ to Pivotal Cloud Foundry
. Build the application
+
[source,bash]
---------------------------------------------------------------------
$ mvn clean package
---------------------------------------------------------------------

. When running a Spring Boot application on Pivotal Cloud Foundry with the actuator endpoints enabled, you can visualize actuator management information on the Applications Manager app dashboard.  To enable this there are a few properties we need to add.  Add the following to */cloud-native-spring/src/main/resources/application.yml*:
+
[source, yaml]
---------------------------------------------------------------------
management:
  security:
    enabled: false
  info:
    git:
      mode: full
  cloudfoundry:
    enabled: true
    skip-ssl-validation: true
---------------------------------------------------------------------

. In order to add full build information to you artifact that is pushed to cloudfoundry, update */cloud-native-spring/pom.xml* and add the following execution and classifier to the spring-boot-maven-plugin:
+
[source, xml]
---------------------------------------------------------------------
<executions>
  <execution>
	  <goals>
		  <goal>build-info</goal>
		</goals>
	</execution>
</executions>
<configuration>
	<classifier>exec</classifier>
</configuration>
---------------------------------------------------------------------
+
The full plugin config should look like the following:
+
[source, xml]
---------------------------------------------------------------------
<plugin>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-maven-plugin</artifactId>
	<executions>
		<execution>
			<goals>
			  <goal>build-info</goal>
		  </goals>
	  </execution>
  </executions>
	<configuration>
	  <classifier>exec</classifier>
  </configuration>
</plugin>
---------------------------------------------------------------------

. By specifying a classifier we actually just produced 2 jars, one that is executable and one that can be used as an artifact that could be included in other apps (such as our Client UI app).  Because of this we need to change the name of the jar we included in our manifest.yml file.  Change the jar in the path property to *./target/cloud-native-spring-0.0.1-SNAPSHOT-exec.jar*:
+
[source, yaml]
---------------------------------------------------------------------
---
applications:
- name: cloud-native-spring
  host: cloud-native-spring-${random-word}
  memory: 512M
  instances: 1
  path: ./target/cloud-native-spring-0.0.1-SNAPSHOT-exec.jar
  buildpack: java_buildpack
  timeout: 180 # to give time for the data to import
  env:
    JAVA_OPTS: -Djava.security.egd=file:///dev/urandom
---------------------------------------------------------------------
. Push application into Cloud Foundry
+
$ mvn clean package
$ cf push -f manifest.yml

. Find the URL created for your app in the health status report. Browse to your app.  Also view your application details in the Apps Manager UI:
+
image::images/appsman.jpg[]

. From this UI you can also dynamically change logging levels:
+
image::images/logging.jpg[]

*Congratulations!* You’ve just learned how to add health and metrics to any Spring Boot application.
